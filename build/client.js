// Generated by CoffeeScript 1.7.1
(function() {
  var Table, argv, client, conn, fs, handler, logger, net, options, parts, ssh, winston;

  argv = require('optimist')["default"]('p', 9922)["default"]('h', '127.0.0.1')["default"]('c', null)["default"]('ssh-host', null)["default"]('ssh-user', 'root')["default"]('ssh-key', null)["default"]('ssh-password', null).argv;

  net = require('net');

  winston = require('winston');

  ssh = require('ssh2');

  fs = require('fs');

  Table = require('cli-table');

  logger = new winston.Logger({
    transports: [
      new winston.transports.Console({
        handleExceptions: true,
        level: 'info',
        prettyPrint: true,
        colorize: true,
        timestamp: true
      })
    ],
    exitOnError: false,
    levels: {
      info: 0,
      warn: 1,
      error: 3
    },
    colors: {
      info: 'green',
      warn: 'yellow',
      error: 'red'
    }
  });

  handler = function(client) {
    var first;
    first = true;
    return client.on('data', function(data) {
      var e, info, name, table, time;
      try {
        info = JSON.parse(data);
      } catch (_error) {
        e = _error;
        return logger.error(e);
      }
      if (first) {
        first = false;
        if (argv.c != null) {
          if (info[argv.c] == null) {
            client.end();
            throw new Error("" + argv.c + " is not an available channel");
          } else {
            client.write(argv.c);
            return logger.info("listening at " + argv.c);
          }
        } else {
          client.end();
          console.log("Available Channels:\n");
          table = new Table({
            head: ['Channel Name', 'Last Update'],
            colWidths: [40, 30]
          });
          for (name in info) {
            time = info[name];
            table.push([name, time]);
          }
          console.log(table.toString());
          return process.exit(1);
        }
      } else {
        return console.log("" + info[0] + ": " + info[1]);
      }
    });
  };

  if (argv['ssh-host'] != null) {
    parts = argv['ssh-host'].split(':');
    options = {
      host: parts[0],
      port: parts[1] != null ? parseInt(parts[1]) : 22,
      username: argv['ssh-user'],
      tryKeyboard: true
    };
    if (argv['ssh-key'] != null) {
      options.privateKey = fs.readFileSync(argv['ssh-key']);
    } else {
      options.passowrd = argv['ssh-password'];
    }
    conn = new ssh.Client;
    conn.on('ready', function() {
      logger.info("ssh connected to " + options.host + ":" + options.port);
      return conn.forwardOut('127.0.0.1', 9933, argv.h, argv.p, function(err, stream) {
        if (err != null) {
          throw err;
        }
        logger.info("connected to " + argv.h + ":" + argv.p);
        return handler(stream);
      });
    }).connect(options);
  } else {
    client = net.connect(argv.p, argv.h, function() {
      return logger.info("connected to " + argv.h + ":" + argv.p);
    });
    handler(client);
  }

}).call(this);
